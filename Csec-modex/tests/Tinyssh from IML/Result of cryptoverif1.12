{ /home/faezeh/csec-modex/src/symtrace/cvtrace IML_client.txt IML_server.txt /home/faezeh/csec-modex/deps/cryptoverif1.12/default model.cv.in | tee model.cv.out; } > model.cv.debug.out 2>&1
for f in model.cv.out; do\
	/home/faezeh/csec-modex/deps/cryptoverif1.12/cryptoverif -lib /home/faezeh/csec-modex/deps/cryptoverif1.12/default $f;\
done
Doing expand if, let, find... No change.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... Done.
Doing remove assignments of useless... Done.
Trying equivalence
equiv ! !_33 <= @5_N3 new @5_r: skeyseed; (
  ! !_34 <= @5_N @5_Omac(@5_x: bitstring) := HMAC_sha1(@5_x, mkgen(@5_r)),
  ! !_35 <= @5_N2 @5_Ocheck(@5_m: bitstring, @5_ma: bitstring) := HMAC_sha1_check(@5_m, mkgen(@5_r), @5_ma))
<=(@5_N3 * Pmac(time + (@5_N3 - 1.) * (time(mkgen) + @5_N * time(HMAC_sha1, maxlength(@5_x[!_34, !_33])) + @5_N2 * time(HMAC_sha1_check, maxlength(@5_m[!_35, !_33]), maxlength(@5_ma[!_35, !_33]))), @5_N, @5_N2, max(maxlength(@5_x[!_34, !_33]), maxlength(@5_m[!_35, !_33]))))=> [computational]
      ! !_36 <= @5_N3 new @5_r: skeyseed [unchanged]; (
  ! !_37 <= @5_N @5_Omac(@5_x_49: bitstring) := let @5_x: bitstring = @5_x_49 in @5_mac2(@5_x, @5_mkgen2(@5_r)),
  ! !_38 <= @5_N2 @5_Ocheck(@5_m: bitstring, @5_ma: bitstring) := find @5_j <= @5_N suchthat defined(@5_x[@5_j]) && ((@5_m = @5_x[@5_j]) && @5_check2(@5_x[@5_j], @5_mkgen2(@5_r), @5_ma)) then true else false)
... Failed.
===================== Proof starts =======================
Initial state
Game 1 is
! !_39 <= N
in(c_in[!_39], ());
new skS: skeyseed;
let pkS: spkey = pk(skS) in
out(c_out[!_39], pkS);
! !_40 <= N
in(c_in[!_40, !_39], ());
new skP: skeyseed;
let pkP: spkey = pk(skP) in
out(c_out[!_40, !_39], pkP);
(
  ! !_41 <= N
  in(c_in[!_41, !_40, !_39], ());
  new a_43: fixed_64;
  let gA: bitstring = kgen(g, a_43) in
  out(c_out[!_41, !_40, !_39], gA);
  in(c_in[!_41, !_40, !_39], (B: bitstring, sig: bitstring, opks: bitstring));
  let sig1: signature = to_sig(sig) in
  let opkst: spkey = trans(opks) in
  if (pkS = opkst) then
  let h: bitstring = HMAC(gA, B, pkS) in
  let k: bitstring = kgen(B, a_43) in
  let x: bool = verify(sig1, pkS) in
  if (x = true) then
  event AcceptP(pkS, pkP);
  let kPS: fixed_100_key = kdfPtoS(k, h) in
  let kSP: fixed_100_key = kdfStoP(k, h) in
  out(c_out[!_41, !_40, !_39], enc(user_auth, kPS));
  in(c_in[!_41, !_40, !_39], userauth_answer: bitstring);
  let userauth_answer1: bounded_1000_ciphertext = to_cipher(userauth_answer) in
  if (dec(userauth_answer1, kSP) = user_auth) then
  event AcceptP2(pkS, pkP);
  out(c_out[!_41, !_40, !_39], enc(sign(user_answer, skP), kPS))
) | (
  ! !_42 <= N
  in(c_in[!_42, !_40, !_39], (a_63_0: bitstring, a_433_0: bitstring));
  new SKey_704_0: fixed_64;
  let sk_706_0: bitstring = kgen(g, SKey_704_0) in
  let kAB_708_0: bitstring = kgen(a_433_0, SKey_704_0) in
  let HMAC_714_0: bitstring = HMAC(a_433_0, sk_706_0, pkS) in
  event AcceptS(pkS, pkP);
  let signature_720_0: signature = sign(inputs, skS) in
  let kPS_724_0: fixed_100_key = kdfPtoS(kAB_708_0, HMAC_714_0) in
  let kSP_728_0: fixed_100_key = kdfStoP(kAB_708_0, HMAC_714_0) in
  out(c_out[!_42, !_40, !_39], (pkS, sign(inputs, skS), sk_706_0));
  in(c_in[!_42, !_40, !_39], a_732_0: bitstring);
  let a_44: bounded_1000_ciphertext = to_cipher(a_732_0) in
  let Dec_733_0: signature = dec(a_44, kPS_724_0) in
  let Enc_736_0: bounded_1000_ciphertext = enc(Dec_733_0, kSP_728_0) in
  out(c_out[!_42, !_40, !_39], Enc_736_0);
  in(c_in[!_42, !_40, !_39], a_967_0: bitstring);
  let a1: bounded_1000_ciphertext = to_cipher(a_967_0) in
  let Dec_968_0: signature = dec(a1, kPS_724_0) in
  let Ver_972_0: bool = verify(Dec_968_0, pkP) in
  if (Ver_972_0 = true) then
  event AcceptS2(pkS, pkP)
)


Applying move all binders yields

Game 2 is
! !_39 <= N
in(c_in[!_39], ());
new skS: skeyseed;
let pkS: spkey = pk(skS) in
out(c_out[!_39], pkS);
! !_40 <= N
in(c_in[!_40, !_39], ());
new skP: skeyseed;
let pkP: spkey = pk(skP) in
out(c_out[!_40, !_39], pkP);
(
  ! !_41 <= N
  in(c_in[!_41, !_40, !_39], ());
  new a_43: fixed_64;
  let gA: bitstring = kgen(g, a_43) in
  out(c_out[!_41, !_40, !_39], gA);
  in(c_in[!_41, !_40, !_39], (B: bitstring, sig: bitstring, opks: bitstring));
  let opkst: spkey = trans(opks) in
  if (pkS = opkst) then
  let sig1: signature = to_sig(sig) in
  let x: bool = verify(sig1, pkS) in
  if (x = true) then
  event AcceptP(pkS, pkP);
  let k: bitstring = kgen(B, a_43) in
  let h: bitstring = HMAC(gA, B, pkS) in
  let kPS: fixed_100_key = kdfPtoS(k, h) in
  let kSP: fixed_100_key = kdfStoP(k, h) in
  out(c_out[!_41, !_40, !_39], enc(user_auth, kPS));
  in(c_in[!_41, !_40, !_39], userauth_answer: bitstring);
  let userauth_answer1: bounded_1000_ciphertext = to_cipher(userauth_answer) in
  if (dec(userauth_answer1, kSP) = user_auth) then
  event AcceptP2(pkS, pkP);
  out(c_out[!_41, !_40, !_39], enc(sign(user_answer, skP), kPS))
) | (
  ! !_42 <= N
  in(c_in[!_42, !_40, !_39], (a_63_0: bitstring, a_433_0: bitstring));
  new SKey_704_0: fixed_64;
  let sk_706_0: bitstring = kgen(g, SKey_704_0) in
  let kAB_708_0: bitstring = kgen(a_433_0, SKey_704_0) in
  let HMAC_714_0: bitstring = HMAC(a_433_0, sk_706_0, pkS) in
  event AcceptS(pkS, pkP);
  let signature_720_0: signature = sign(inputs, skS) in
  let kPS_724_0: fixed_100_key = kdfPtoS(kAB_708_0, HMAC_714_0) in
  let kSP_728_0: fixed_100_key = kdfStoP(kAB_708_0, HMAC_714_0) in
  out(c_out[!_42, !_40, !_39], (pkS, sign(inputs, skS), sk_706_0));
  in(c_in[!_42, !_40, !_39], a_732_0: bitstring);
  let a_44: bounded_1000_ciphertext = to_cipher(a_732_0) in
  let Dec_733_0: signature = dec(a_44, kPS_724_0) in
  let Enc_736_0: bounded_1000_ciphertext = enc(Dec_733_0, kSP_728_0) in
  out(c_out[!_42, !_40, !_39], Enc_736_0);
  in(c_in[!_42, !_40, !_39], a_967_0: bitstring);
  let a1: bounded_1000_ciphertext = to_cipher(a_967_0) in
  let Dec_968_0: signature = dec(a1, kPS_724_0) in
  let Ver_972_0: bool = verify(Dec_968_0, pkP) in
  if (Ver_972_0 = true) then
  event AcceptS2(pkS, pkP)
)


Applying remove assignments of useless yields

Game 3 is
! !_39 <= N
in(c_in[!_39], ());
new skS: skeyseed;
let pkS: spkey = pk(skS) in
out(c_out[!_39], pkS);
! !_40 <= N
in(c_in[!_40, !_39], ());
new skP: skeyseed;
let pkP: spkey = pk(skP) in
out(c_out[!_40, !_39], pkP);
(
  ! !_41 <= N
  in(c_in[!_41, !_40, !_39], ());
  new a_43: fixed_64;
  let gA: bitstring = kgen(g, a_43) in
  out(c_out[!_41, !_40, !_39], gA);
  in(c_in[!_41, !_40, !_39], (B: bitstring, sig: bitstring, opks: bitstring));
  let opkst: spkey = trans(opks) in
  if (pkS = opkst) then
  let sig1: signature = to_sig(sig) in
  let x: bool = verify(sig1, pkS) in
  if (x = true) then
  event AcceptP(pkS, pkP);
  let k: bitstring = kgen(B, a_43) in
  let h: bitstring = HMAC(gA, B, pkS) in
  let kPS: fixed_100_key = kdfPtoS(k, h) in
  let kSP: fixed_100_key = kdfStoP(k, h) in
  out(c_out[!_41, !_40, !_39], enc(user_auth, kPS));
  in(c_in[!_41, !_40, !_39], userauth_answer: bitstring);
  let userauth_answer1: bounded_1000_ciphertext = to_cipher(userauth_answer) in
  if (dec(userauth_answer1, kSP) = user_auth) then
  event AcceptP2(pkS, pkP);
  out(c_out[!_41, !_40, !_39], enc(sign(user_answer, skP), kPS))
) | (
  ! !_42 <= N
  in(c_in[!_42, !_40, !_39], (a_63_0: bitstring, a_433_0: bitstring));
  new SKey_704_0: fixed_64;
  let sk_706_0: bitstring = kgen(g, SKey_704_0) in
  let kAB_708_0: bitstring = kgen(a_433_0, SKey_704_0) in
  let HMAC_714_0: bitstring = HMAC(a_433_0, sk_706_0, pkS) in
  event AcceptS(pkS, pkP);
  let kPS_724_0: fixed_100_key = kdfPtoS(kAB_708_0, HMAC_714_0) in
  let kSP_728_0: fixed_100_key = kdfStoP(kAB_708_0, HMAC_714_0) in
  out(c_out[!_42, !_40, !_39], (pkS, sign(inputs, skS), sk_706_0));
  in(c_in[!_42, !_40, !_39], a_732_0: bitstring);
  let a_44: bounded_1000_ciphertext = to_cipher(a_732_0) in
  let Dec_733_0: signature = dec(a_44, kPS_724_0) in
  let Enc_736_0: bounded_1000_ciphertext = enc(Dec_733_0, kSP_728_0) in
  out(c_out[!_42, !_40, !_39], Enc_736_0);
  in(c_in[!_42, !_40, !_39], a_967_0: bitstring);
  let a1: bounded_1000_ciphertext = to_cipher(a_967_0) in
  let Dec_968_0: signature = dec(a1, kPS_724_0) in
  let Ver_972_0: bool = verify(Dec_968_0, pkP) in
  if (Ver_972_0 = true) then
  event AcceptS2(pkS, pkP)
)

RESULT Could not prove event AcceptS2(i, j) ==> AcceptP2(i, j), event AcceptP(i, j) ==> AcceptS(i, l).

