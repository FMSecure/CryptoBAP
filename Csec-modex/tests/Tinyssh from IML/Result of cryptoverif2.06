Doing expand get, insert and prove unique annotations... No change.
Doing simplify (non-expanded game)... No change.
Doing expand... Done.
Doing remove assignments of findcond... Done.
Doing simplify... Run simplify 2 time(s). Fixpoint reached.
Done.
Doing move all binders... Done.
Doing remove assignments of findcond... No change.
Doing merge branches... No change.
Proof of event(AcceptP(i, j)) ==> event(AcceptS(i, l)) failed:
  Found AcceptP(pkS, pkP) at 100
  but could not prove event(AcceptS(i, l))
Proof of event(AcceptS2(i, j)) ==> event(AcceptP2(i, j)) failed:
  Found AcceptS2(pkS, pkP) at 481
  but could not prove event(AcceptP2(i, j))
Proved query event(AcceptP(i, j)) ==> true
Proved query event(AcceptS2(i, j)) ==> true
Proved query event(AcceptS(i, l)) ==> true
Proved query event(AcceptP2(i, j)) ==> true
Trying equivalence uf_cma(sign)... Failed.
Trying equivalence cdh(exp)... Failed.
Doing remove assignments of binder skP... Done.
Doing remove assignments of binder pkP... Done.
Trying equivalence uf_cma(sign) with r_4, P_seed... Transf. OK Proba. computed Transf. done Succeeded.
Doing simplify (non-expanded game)... Applied collision new r1: skeyseed; new r2: skeyseed; return((spkgen(r1) = pkgen2(r2))) <=(Psigncoll)=> return(false) with r2 -> P_seed[ri_4, ri_5], r1 -> S_seed Probability: Psigncoll * N * N * N
Done.
Doing expand... Done.
Doing remove assignments of findcond... Done.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of findcond... No change.
Doing merge branches... No change.
Proof of event(AcceptP(i, j)) ==> event(AcceptS(i, l)) failed:
  Found AcceptP(pkS, pkgen2(P_seed)) at 96
  but could not prove event(AcceptS(i, l))
Proved query event(AcceptS2(i, j)) ==> event(AcceptP2(i, j))
Trying equivalence uf_cma(sign)... Failed.
Trying equivalence cdh(exp)... Failed.
Doing remove assignments of binder skS... Done.
Doing remove assignments of binder pkS... Done.
Trying equivalence uf_cma(sign) with S_seed... Transf. OK Proba. computed Transf. done Succeeded.
Doing simplify (non-expanded game)... Done.
Doing expand... Done.
Doing remove assignments of findcond... Done.
Doing simplify... Run simplify 1 time(s). Fixpoint reached.
No change.
Doing move all binders... No change.
Doing remove assignments of findcond... No change.
Doing merge branches... No change.
Proved query event(AcceptP(i, j)) ==> event(AcceptS(i, l))
===================== Proof starts =======================
Initial state
Game 1 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let skP: sskey = sskgen(P_seed) in
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let sig1: signature = to_sig(sig) in
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let h_1: macres = mac(gA, B, hk_1) in
       let k: G = exp(B, a) in
       let x: bool = check(bl, pkS, sig1) in
       if x = true then
       event AcceptP(pkS, pkP);
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let sig2: signature = (let m_4: block = user_answer in new r_4: sign_seed; sign_r(m_4, skP, r_4)) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring);
{272}    if c_0 = a_63 then
         event bad
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
         let signature_677: signature = (let m_5: block = inputs in new r_5: sign_seed; sign_r(m_5, skS, r_5)) in
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         out(c_out[i_5, i_3, i_1, i], (pkS, (let m_6: block = inputs in new r_6: sign_seed; sign_r(m_6, skS, r_6)), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring);
{466}      if c_0 = a_5173 then
           event bad;
{483}      let Pars1_5177: bitstring = pars1(a_5173) in
{491}      if c_50 = Pars1_5177 then
           event bad;
{508}      let Pars2_5183: bitstring = pars2(a_5173) in
{516}      if c_256 = Pars2_5183 then
           event bad
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if Ver_972 = true then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Applying expand
  - Expand if/find/let
    - Merge branches of test at 516
    - Remove let at 508
    - Merge branches of test at 491
    - Remove let at 483
    - Merge branches of test at 466
    - Merge branches of test at 272
yields

Game 2 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let skP: sskey = sskgen(P_seed) in
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let sig1: signature = to_sig(sig) in
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let h_1: macres = mac(gA, B, hk_1) in
       let k: G = exp(B, a) in
       let x: bool = check(bl, pkS, sig1) in
       if x = true then
       event AcceptP(pkS, pkP);
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, skP, r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
         let m_5: block = inputs in
         new r_5: sign_seed;
         let signature_677: signature = sign_r(m_5, skS, r_5) in
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if Ver_972 = true then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Applying remove assignments of findcond
  - Remove assignments on signature_677 (definition removed, all usages removed)
  - Remove assignments on m_5 (definition removed, all usages removed)
yields

Game 3 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let skP: sskey = sskgen(P_seed) in
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let sig1: signature = to_sig(sig) in
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let h_1: macres = mac(gA, B, hk_1) in
       let k: G = exp(B, a) in
       let x: bool = check(bl, pkS, sig1) in
       if {117}(x = true) then
       event AcceptP(pkS, pkP);
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, skP, r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
{327}    new r_5: sign_seed;
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if {477}(Ver_972 = true) then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Applying simplify
  - Simplification pass
    - Replaced (Ver_972 = true) with Ver_972 at 477
    - Remove random number generation at 327
    - Replaced (x = true) with x at 117
yields

Game 4 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let skP: sskey = sskgen(P_seed) in
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let sig1: signature = to_sig(sig) in
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let h_1: macres = mac(gA, B, hk_1) in
       let k: G = exp(B, a) in
       let x: bool = check(bl, pkS, sig1) in
       if x then
       event AcceptP(pkS, pkP);
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, skP, r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if Ver_972 then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Applying move all binders
  - Move assignment to k
  - Move assignment to h_1
  - Move assignment to sig1
yields

Game 5 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let skP: sskey = sskgen(P_seed) in
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let x: bool = check(bl, pkS, sig1) in
       if x then
       event AcceptP(pkS, pkP);
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, skP, r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if Ver_972 then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Proved event(AcceptP2(i, j)) ==> true in game 5
Proved event(AcceptS(i, l)) ==> true in game 5
Proved event(AcceptS2(i, j)) ==> true in game 5
Proved event(AcceptP(i, j)) ==> true in game 5

Applying remove assignments of binder skP
  - Remove assignments on skP (definition removed, all usages removed)
yields

Game 6 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     let pkP: spkey = spkgen(P_seed) in
     out(c_out[i_1, i], pkP);
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let x: bool = check(bl, pkS, sig1) in
       if x then
       event AcceptP(pkS, pkP);
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkP);
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, sskgen(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkP);
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, pkP, sig4) in
           if Ver_972 then
           event AcceptS2(pkS, pkP)
         ))
       ))
     ))


Applying remove assignments of binder pkP
  - Remove assignments on pkP (definition removed, all usages removed)
yields

Game 7 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], spkgen(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let x: bool = check(bl, pkS, sig1) in
       if x then
       event AcceptP(pkS, spkgen(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, spkgen(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r(m_4, sskgen(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, spkgen(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = check(bl, spkgen(P_seed), sig4) in
           if Ver_972 then
           event AcceptS2(pkS, spkgen(P_seed))
         ))
       ))
     ))


Applying equivalence uf_cma(sign) with r_4, P_seed [probability N^2 * Psign(time_1, N)]
  - Equivalence uf_cma(sign) with variables: P_seed -> r_1, r_4 -> r2
yields

Game 8 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let x: bool = (let m: block = bl in (let y_1: spkey = pkS in (let si: signature = sig1 in {87}find u_1 = ri_3 <= N, u_2 = ri_4 <= N, u_3 = ri_5 <= N suchthat defined(x_1[ri_3, ri_4, ri_5], P_seed[ri_4, ri_5]) && {93}((y_1 = pkgen2(P_seed[ri_4, ri_5])) && (m = x_1[ri_3, ri_4, ri_5]) && check2(m, y_1, si)) then true else {127}find u_4 = ri_6 <= N, u_5 = ri_7 <= N suchthat defined(P_seed[ri_6, ri_7]) && {130}(y_1 = pkgen2(P_seed[ri_6, ri_7])) then false else check(m, y_1, si)))) in
       if x then
       event AcceptP(pkS, pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = (let x_1: block = m_4 in sign_r2(x_1, skgen2(P_seed), r_4)) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
           let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
           let sig4: signature = from_bot_to_sig(Dec_6161) in
           let Ver_972: bool = (let m1: block = bl in (let si1: signature = sig4 in {539}find u = ri <= N suchthat defined(x_1[ri]) && {543}((m1 = x_1[ri]) && check2(m1, pkgen2(P_seed), si1)) then true else false)) in
           if Ver_972 then
           event AcceptS2(pkS, pkgen2(P_seed))
         ))
       ))
     ))


Applying simplify (non-expanded game) [probability N^3 * Psigncoll]
  - Simplification pass
    - Replaced ((y_1 = pkgen2(P_seed[ri_4, ri_5])) && (m = x_1[ri_3, ri_4, ri_5]) && check2(m, y_1, si)) with false at 93
    - Remove branch 1 in find at 87
    - Find at 87 removed (else branch kept if any)
    - Replaced (y_1 = pkgen2(P_seed[ri_6, ri_7])) with false at 130
    - Remove branch 1 in find at 127
    - Find at 127 removed (else branch kept if any)
    - Replaced ((m1 = x_1[ri]) && check2(m1, pkgen2(P_seed), si1)) with false at 543
    - Remove branch 1 in find at 539
    - Find at 539 removed (else branch kept if any)
yields

Game 9 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let x: bool = (let m: block = bl in (let y_1: spkey = pkS in (let si: signature = sig1 in check(m, y_1, si)))) in
       if x then
       event AcceptP(pkS, pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = (let x_1: block = m_4 in sign_r2(x_1, skgen2(P_seed), r_4)) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring);
{455}      let Dec_6161: bitstringbot = dec(a_6160, kPS_681) in
{468}      let sig4: signature = from_bot_to_sig(Dec_6161) in
{476}      let Ver_972: bool = {477}(let m1: block = bl in {479}(let si1: signature = sig4 in false)) in
{487}      if Ver_972 then
           event AcceptS2(pkS, pkgen2(P_seed))
         ))
       ))
     ))


Applying expand
  - Expand if/find/let
    - Test at 487 always false
    - Remove let at 476
    - Remove let at 479
    - Remove let at 477
    - Remove let at 468
    - Remove let at 455
yields

Game 10 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let m: block = bl in
       let y_1: spkey = pkS in
       let si: signature = sig1 in
       let x: bool = check(m, y_1, si) in
       if x then
       event AcceptP(pkS, pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let x_1: block = m_4 in
       let sig2: signature = sign_r2(x_1, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying remove assignments of findcond
  - Remove assignments on y_1 (definition removed, all usages removed)
  - Remove assignments on si (definition removed, all usages removed)
  - Remove assignments on x_1 (definition removed, all usages removed)
yields

Game 11 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let skS: sskey = sskgen(S_seed) in
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let m: block = bl in
       let x: bool = check(m, pkS, sig1) in
       if x then
       event AcceptP(pkS, pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r2(m_4, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, skS, r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Proved event(AcceptS2(i, j)) ==> event(AcceptP2(i, j)) in game 11

Applying remove assignments of binder skS
  - Remove assignments on skS (definition removed, all usages removed)
yields

Game 12 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     let pkS: spkey = spkgen(S_seed) in
     out(c_out[i], pkS);
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkS = opkst then
       let sig1: signature = to_sig(sig) in
       let m: block = bl in
       let x: bool = check(m, pkS, sig1) in
       if x then
       event AcceptP(pkS, pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkS, pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r2(m_4, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkS, pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkS, sign_r(m_6, sskgen(S_seed), r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying remove assignments of binder pkS
  - Remove assignments on pkS (definition removed, all usages removed)
yields

Game 13 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     out(c_out[i], spkgen(S_seed));
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if spkgen(S_seed) = opkst then
       let sig1: signature = to_sig(sig) in
       let m: block = bl in
       let x: bool = check(m, spkgen(S_seed), sig1) in
       if x then
       event AcceptP(spkgen(S_seed), pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(spkgen(S_seed), pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r2(m_4, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(spkgen(S_seed), pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (spkgen(S_seed), sign_r(m_6, sskgen(S_seed), r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying equivalence uf_cma(sign) with S_seed [probability N * Psign(time_2, N^3)]
  - Equivalence uf_cma(sign) with variables: r_6 -> r2, S_seed -> r_1
yields

Game 14 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     out(c_out[i], pkgen2(S_seed));
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
       let opkst: spkey = trans(opks) in
       if pkgen2(S_seed) = opkst then
       let sig1: signature = to_sig(sig) in
       let m: block = bl in
       let x: bool = (let m1_1: block = m in (let si1_1: signature = sig1 in {83}find u_6 = ri_8 <= N, u_7 = ri_9 <= N, u_8 = ri_10 <= N suchthat defined(x_2[ri_8, ri_9, ri_10]) && {88}((m1_1 = x_2[ri_8, ri_9, ri_10]) && check2(m1_1, pkgen2(S_seed), si1_1)) then true else false)) in
       if x then
       event AcceptP(pkgen2(S_seed), pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkgen2(S_seed), pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r2(m_4, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkgen2(S_seed), pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkgen2(S_seed), (let x_2: block = m_6 in sign_r2(x_2, skgen2(S_seed), r_6)), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying simplify (non-expanded game)
  - Simplification pass
    - Replaced ((m1_1 = x_2[ri_8, ri_9, ri_10]) && check2(m1_1, pkgen2(S_seed), si1_1)) with false at 88
    - Remove branch 1 in find at 83
    - Find at 83 removed (else branch kept if any)
yields

Game 15 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     out(c_out[i], pkgen2(S_seed));
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring));
 {49}  let opkst: spkey = trans(opks) in
 {55}  if pkgen2(S_seed) = opkst then
 {64}  let sig1: signature = to_sig(sig) in
 {70}  let m: block = bl in
 {72}  let x: bool = {73}(let m1_1: block = m in {78}(let si1_1: signature = sig1 in false)) in
 {84}  if x then
       event AcceptP(pkgen2(S_seed), pkgen2(P_seed));
       let k: G = exp(B, a) in
       let h_1: macres = mac(gA, B, hk_1) in
       let kPS: symkey = kdfPtoS(k, h_1) in
       let kSP: symkey = kdfStoP(k, h_1) in
       out(c_out[i_2, i_1, i], enc(user_auth, kPS));
       in(c_in[i_2, i_1, i], userauth_answer: bitstring);
       let user_auth1: bitstringbot = to_bot(user_auth) in
       if dec(userauth_answer, kSP) = user_auth1 then
       event AcceptP2(pkgen2(S_seed), pkgen2(P_seed));
       let y: bitstring = conc(c_50, c_128) in
       out(c_out[i_2, i_1, i], y);
       in(c_in[i_2, i_1, i], ());
       let m_4: block = user_answer in
       new r_4: sign_seed;
       let sig2: signature = sign_r2(m_4, skgen2(P_seed), r_4) in
       let sig3: bitstring = from_sig(sig2) in
       out(c_out[i_2, i_1, i], enc(sig3, kPS))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkgen2(S_seed), pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkgen2(S_seed), (let x_2: block = m_6 in sign_r2(x_2, skgen2(S_seed), r_6)), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying expand
  - Expand if/find/let
    - Test at 84 always false
    - Remove let at 72
    - Remove let at 78
    - Remove let at 73
    - Remove let at 70
    - Remove let at 64
    - Merge branches of test at 55
    - Remove let at 49
yields

Game 16 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     out(c_out[i], pkgen2(S_seed));
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkgen2(S_seed), pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         let x_2: block = m_6 in
         out(c_out[i_5, i_3, i_1, i], (pkgen2(S_seed), sign_r2(x_2, skgen2(S_seed), r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Applying remove assignments of findcond
  - Remove assignments on x_2 (definition removed, all usages removed)
yields

Game 17 is
     ! i <= N
     in(c_in[i], ());
     new hk_1: mkey;
     new S_seed: skeyseed;
     out(c_out[i], pkgen2(S_seed));
     ! i_1 <= N
     in(c_in[i_1, i], ());
     new P_seed: skeyseed;
     out(c_out[i_1, i], pkgen2(P_seed));
     ((
       ! i_2 <= N
       in(c_in[i_2, i_1, i], ());
       new a: Z;
       let gA: G = exp(g, a) in
       out(c_out[i_2, i_1, i], gA);
       in(c_in[i_2, i_1, i], (B: G, sig: bitstring, opks: bitstring))
     ) | (
       ! i_3 <= N
       ((
         ! i_4 <= N
         in(c_in[i_4, i_3, i_1, i], a_63: bitstring)
       ) | (
         ! i_5 <= N
         in(c_in[i_5, i_3, i_1, i], a_429: G);
         new SKey_661: Z;
         let sk_663: G = exp(g, SKey_661) in
         let kAB_665: G = exp(a_429, SKey_661) in
         let HMAC_671: macres = mac(a_429, sk_663, hk_1) in
         event AcceptS(pkgen2(S_seed), pkgen2(P_seed));
         let kPS_681: symkey = kdfPtoS(kAB_665, HMAC_671) in
         let kSP_685: symkey = kdfStoP(kAB_665, HMAC_671) in
         let m_6: block = inputs in
         new r_6: sign_seed;
         out(c_out[i_5, i_3, i_1, i], (pkgen2(S_seed), sign_r2(m_6, skgen2(S_seed), r_6), sk_663));
         in(c_in[i_5, i_3, i_1, i], a_689: bitstring);
         let Dec_690: bitstringbot = dec(a_689, kPS_681) in
         let dec1: bitstring = from_bot(Dec_690) in
         let Enc_693: bitstring = enc(dec1, kSP_685) in
         out(c_out[i_5, i_3, i_1, i], Enc_693);
         ((
           ! i_6 <= N
           in(c_in[i_6, i_5, i_3, i_1, i], a_5173: bitstring)
         ) | (
           ! i_7 <= N
           in(c_in[i_7, i_5, i_3, i_1, i], a_6160: bitstring)
         ))
       ))
     ))


Proved event(AcceptP(i, j)) ==> event(AcceptS(i, l)) in game 17
Adv[Game 1: event(AcceptP2(i, j)) ==> true] <= 0 + Adv[Game 5: event(AcceptP2(i, j)) ==> true]
Adv[Game 5: event(AcceptP2(i, j)) ==> true] <= 0
RESULT Proved event(AcceptP2(i, j)) ==> true
Adv[Game 1: event(AcceptS(i, l)) ==> true] <= 0 + Adv[Game 5: event(AcceptS(i, l)) ==> true]
Adv[Game 5: event(AcceptS(i, l)) ==> true] <= 0
RESULT Proved event(AcceptS(i, l)) ==> true
Adv[Game 1: event(AcceptS2(i, j)) ==> true] <= 0 + Adv[Game 5: event(AcceptS2(i, j)) ==> true]
Adv[Game 5: event(AcceptS2(i, j)) ==> true] <= 0
RESULT Proved event(AcceptS2(i, j)) ==> true
Adv[Game 1: event(AcceptP(i, j)) ==> true] <= 0 + Adv[Game 5: event(AcceptP(i, j)) ==> true]
Adv[Game 5: event(AcceptP(i, j)) ==> true] <= 0
RESULT Proved event(AcceptP(i, j)) ==> true
Adv[Game 1: event(AcceptS2(i, j)) ==> event(AcceptP2(i, j))] <= N^3 * Psigncoll + N^2 * Psign(time_1, N) + Adv[Game 11: event(AcceptS2(i, j)) ==> event(AcceptP2(i, j))]
Adv[Game 11: event(AcceptS2(i, j)) ==> event(AcceptP2(i, j))] <= 0
RESULT Proved event(AcceptS2(i, j)) ==> event(AcceptP2(i, j)) up to probability N^3 * Psigncoll + N^2 * Psign(time_1, N)
Adv[Game 1: event(AcceptP(i, j)) ==> event(AcceptS(i, l))] <= N * Psign(time_2, N^3) + N^3 * Psigncoll + N^2 * Psign(time_1, N) + Adv[Game 17: event(AcceptP(i, j)) ==> event(AcceptS(i, l))]
Adv[Game 17: event(AcceptP(i, j)) ==> event(AcceptS(i, l))] <= 0
RESULT Proved event(AcceptP(i, j)) ==> event(AcceptS(i, l)) up to probability N * Psign(time_2, N^3) + N^3 * Psigncoll + N^2 * Psign(time_1, N)
RESULT time_1 = (N + N^2 - 1) * time(sskgen) + (N + N^2 - 1) * time(spkgen) + N^3 * time(trans, maxlength(game 7: opks)) + N^3 * time(to_sig, maxlength(game 7: sig)) + (2 * N^3 + 2 * N^4) * time(exp) + (N^3 + N^4) * time(mac) + N^3 * time(kdfPtoS, maxlength(game 7: h_1)) + N^3 * time(kdfStoP, maxlength(game 7: h_1)) + N^3 * time(enc, length(user_auth)) + N^3 * time(to_bot, length(user_auth)) + N^3 * time(= bitstringbot, length(dec, maxlength(game 7: userauth_answer)), maxlength(game 7: user_auth1)) + N^3 * time(dec, maxlength(game 7: userauth_answer)) + 2 * N^3 * time(([1,N], [1,N], [1,N])) + N^3 * time(conc, length(c_50), length(c_128)) + N^3 * time(from_sig) + N^3 * time(enc, maxlength(game 7: sig3)) + N^4 * time(([1,N], [1,N], [1,N], [1,N])) + N^4 * time(kdfPtoS, maxlength(game 7: HMAC_671)) + N^4 * time(kdfStoP, maxlength(game 7: HMAC_671)) + (N^4 + N^3 - N) * time(sign_r) + N^4 * time(dec, maxlength(game 7: a_689)) + N^4 * time(from_bot, maxlength(game 7: Dec_690)) + N^4 * time(enc, maxlength(game 7: dec1)) + N^5 * time(dec, maxlength(game 7: a_6160)) + N^5 * time(from_bot_to_sig, maxlength(game 7: Dec_6161)) + N^5 * time(([1,N], [1,N], [1,N], [1,N], [1,N])) + time + (N^3 + N^5 - 1) * time(check)
RESULT time_2 = (N^2 + 2 * N^3 + N^4) * time(pkgen2) + N^3 * time(trans, maxlength(game 13: opks)) + N^3 * time(to_sig, maxlength(game 13: sig)) + (2 * N^3 + 2 * N^4) * time(exp) + (N^3 + N^4) * time(mac) + N^3 * time(kdfPtoS, maxlength(game 13: h_1)) + N^3 * time(kdfStoP, maxlength(game 13: h_1)) + N^3 * time(enc, length(user_auth)) + N^3 * time(to_bot, length(user_auth)) + N^3 * time(= bitstringbot, length(dec, maxlength(game 13: userauth_answer)), maxlength(game 13: user_auth1)) + N^3 * time(dec, maxlength(game 13: userauth_answer)) + 2 * N^3 * time(([1,N], [1,N], [1,N])) + N^3 * time(conc, length(c_50), length(c_128)) + N^3 * time(sign_r2) + N^3 * time(skgen2) + N^3 * time(from_sig) + N^3 * time(enc, maxlength(game 13: sig3)) + N^4 * time(([1,N], [1,N], [1,N], [1,N])) + N^4 * time(kdfPtoS, maxlength(game 13: HMAC_671)) + N^4 * time(kdfStoP, maxlength(game 13: HMAC_671)) + N^4 * time(dec, maxlength(game 13: a_689)) + N^4 * time(from_bot, maxlength(game 13: Dec_690)) + N^4 * time(enc, maxlength(game 13: dec1)) + time + (N^3 - 1) * time(check) + (N^4 - N^3) * time(sign_r) + (N - 1) * time(sskgen) + (N - 1) * time(spkgen)
All queries proved.

RESULT Proved event(AcceptP2(i, j)) ==> true
RESULT Proved event(AcceptS(i, l)) ==> true
RESULT Proved event(AcceptS2(i, j)) ==> true
RESULT Proved event(AcceptP(i, j)) ==> true
RESULT Proved event(AcceptS2(i, j)) ==> event(AcceptP2(i, j)) up to probability N^3 * Psigncoll + N^2 * Psign(time_1, N)
RESULT Proved event(AcceptP(i, j)) ==> event(AcceptS(i, l)) up to probability N * Psign(time_2, N^3) + N^3 * Psigncoll + N^2 * Psign(time_1, N)
RESULT time_1 = (N + N^2 - 1) * time(sskgen) + (N + N^2 - 1) * time(spkgen) + N^3 * time(trans, maxlength(game 7: opks)) + N^3 * time(to_sig, maxlength(game 7: sig)) + (2 * N^3 + 2 * N^4) * time(exp) + (N^3 + N^4) * time(mac) + N^3 * time(kdfPtoS, maxlength(game 7: h_1)) + N^3 * time(kdfStoP, maxlength(game 7: h_1)) + N^3 * time(enc, length(user_auth)) + N^3 * time(to_bot, length(user_auth)) + N^3 * time(= bitstringbot, length(dec, maxlength(game 7: userauth_answer)), maxlength(game 7: user_auth1)) + N^3 * time(dec, maxlength(game 7: userauth_answer)) + 2 * N^3 * time(([1,N], [1,N], [1,N])) + N^3 * time(conc, length(c_50), length(c_128)) + N^3 * time(from_sig) + N^3 * time(enc, maxlength(game 7: sig3)) + N^4 * time(([1,N], [1,N], [1,N], [1,N])) + N^4 * time(kdfPtoS, maxlength(game 7: HMAC_671)) + N^4 * time(kdfStoP, maxlength(game 7: HMAC_671)) + (N^4 + N^3 - N) * time(sign_r) + N^4 * time(dec, maxlength(game 7: a_689)) + N^4 * time(from_bot, maxlength(game 7: Dec_690)) + N^4 * time(enc, maxlength(game 7: dec1)) + N^5 * time(dec, maxlength(game 7: a_6160)) + N^5 * time(from_bot_to_sig, maxlength(game 7: Dec_6161)) + N^5 * time(([1,N], [1,N], [1,N], [1,N], [1,N])) + time + (N^3 + N^5 - 1) * time(check)
RESULT time_2 = (N^2 + 2 * N^3 + N^4) * time(pkgen2) + N^3 * time(trans, maxlength(game 13: opks)) + N^3 * time(to_sig, maxlength(game 13: sig)) + (2 * N^3 + 2 * N^4) * time(exp) + (N^3 + N^4) * time(mac) + N^3 * time(kdfPtoS, maxlength(game 13: h_1)) + N^3 * time(kdfStoP, maxlength(game 13: h_1)) + N^3 * time(enc, length(user_auth)) + N^3 * time(to_bot, length(user_auth)) + N^3 * time(= bitstringbot, length(dec, maxlength(game 13: userauth_answer)), maxlength(game 13: user_auth1)) + N^3 * time(dec, maxlength(game 13: userauth_answer)) + 2 * N^3 * time(([1,N], [1,N], [1,N])) + N^3 * time(conc, length(c_50), length(c_128)) + N^3 * time(sign_r2) + N^3 * time(skgen2) + N^3 * time(from_sig) + N^3 * time(enc, maxlength(game 13: sig3)) + N^4 * time(([1,N], [1,N], [1,N], [1,N])) + N^4 * time(kdfPtoS, maxlength(game 13: HMAC_671)) + N^4 * time(kdfStoP, maxlength(game 13: HMAC_671)) + N^4 * time(dec, maxlength(game 13: a_689)) + N^4 * time(from_bot, maxlength(game 13: Dec_690)) + N^4 * time(enc, maxlength(game 13: dec1)) + time + (N^3 - 1) * time(check) + (N^4 - N^3) * time(sign_r) + (N - 1) * time(sskgen) + (N - 1) * time(spkgen)

