
(**********************************
  Tinyssh protocol.
***********************************)
param N,N'.
channel c_in, c_out.
type pad_rand [fixed]. (*size 255 bytes or less depending on how the padding is done*)
type cookie [fixed, large]. (* 16 bytes *)
type tag [bounded]. (* 1 byte *)
type uint32 [bounded]. (* 4 bytes *)
type D [fixed].
type hashkey [bounded].
type hash [fixed, large].
type signature [bounded].
type block [fixed].
type skeyseed [large, fixed].
type sskey [bounded, large].
type spkey [bounded, large].
type mkey [bounded, large].
type macinput [bounded].
type macres [large].
type iv [fixed, large].
type symkey [fixed, large].

fun skp(spkey,sskey): bitstring [data].

type Z [large, bounded]. (*mpint = ssh string (size+string payload). MSB. 8 bits per byte. where 0=empty string, >0=first bit=0, <0=first bit=1,at beginning no useless 00 or FF. *)
type G [large, bounded]. (*mpint*)

fun bitstring_of_G(G): bitstring [data].

fun padr(bitstring,pad_rand): bitstring.
letfun pad(m:bitstring) = r <-R pad_rand; padr(m, r).
fun unpad(bitstring): bitstringbot.

fun injbot(bitstring): bitstringbot [data].
equation forall x: bitstring; injbot (x) <> bottom.
equation forall x: bitstring, r: pad_rand;
       unpad(padr(x, r)) = injbot(x).

(* utils *)

fun get_size(bitstring): uint32.

fun concatm(tag, bitstring): bitstring [data].
fun concatKEXINIT(cookie, bitstring): bitstring [data].
fun concat8(bitstring, bitstring, bitstring, bitstring, spkey, G, G, G): bitstring [data].
fun concatKEXDHREPLY(spkey, G, signature): bitstring [data].
fun concat(bitstring, bitstring): bitstring.
fun concatnm(uint32, bitstring): bitstring [data].
fun concatem(bitstring, macres): bitstring [data].
fun check_algorithms(bitstring): bool.
fun block_of_hash(hash): block [data].

const negotiation_string: bitstring.
const tag_kexdh_init: tag.
const tag_kexdh_reply: tag.
const tag_kex_init: tag.
const tag_newkeys: tag.
const uint32_zero: uint32.
const null_string: bitstring. (*the string of length 0 *)

(*CDH*)

expand DH_basic(G, Z, g, exp, exp', mult).

proba pCDH.
expand CDH(G, Z, g, exp, exp', mult, pCDH).

letfun message(x: Z) = exp(g, x).

(*MAC*)

fun mac(G, G, mkey): macres.
fun check_mac(G, G, mkey, macres): bool.

equation forall m: G, m1: G, k: mkey;
	check_mac(m, m1, k, mac(m, m1, k)).

(* symmetric encryption *)

fun enc(bitstring, symkey): bitstring.
fun dec(bitstring, symkey): bitstringbot.

equation forall m: bitstring, k: symkey;
    dec(enc(m, k), k) = injbot (m).

(*hash function *)

param qH [noninteractive].
proba Phash.

expand CollisionResistant_hash(hashkey, bitstring, hash, h, hashoracle, Phash).


(* signature *)

proba Psign.
proba Psigncoll.

expand UF_CMA_proba_signature(skeyseed, spkey, sskey, block, signature, sskgen, spkgen, sign, check, Psign, Psigncoll).

letfun kgen_s () = r <-R skeyseed; skp(spkgen(r), sskgen(r)).

(* utils *)

const tag_IVC: tag.
const tag_IVS: tag.
const tag_EKC: tag.
const tag_EKS: tag.
const tag_MKC: tag.
const tag_MKS: tag.

fun iv_of_hash (hash): iv.
fun symkey_of_hash (hash): symkey.
fun mkey_of_hash (hash): mkey.

fun concat4(G, hash, tag, hash): bitstring [data].
letfun gen(hk:hashkey, k:G, h1:hash, c:tag, h2:hash) = h(hk, concat4(k, h1, c, h2)).
letfun genIVC(hk:hashkey, k:G, h1:hash, h2:hash) = iv_of_hash(gen(hk, k, h1, tag_IVC, h2)).
letfun genIVS(hk:hashkey, k:G, h1:hash, h2:hash) = iv_of_hash(gen(hk, k, h1, tag_IVS, h2)).
letfun genEKC(hk:hashkey, k:G, h1:hash, h2:hash) = symkey_of_hash(gen(hk, k, h1, tag_EKC, h2)).
letfun genEKS(hk:hashkey, k:G, h1:hash, h2:hash) = symkey_of_hash(gen(hk, k, h1, tag_EKS, h2)).
letfun genMKC(hk:hashkey, k:G, h1:hash, h2:hash) = mkey_of_hash(gen(hk, k, h1, tag_MKC, h2)).
letfun genMKS(hk:hashkey, k:G, h1:hash, h2:hash) = mkey_of_hash(gen(hk, k, h1, tag_MKS, h2)).

equation forall k: G, h1: hash, c: tag, h2: hash, x1: bitstring, x2: bitstring, x3: bitstring, x4: bitstring, x5: spkey, x6: G, x7: G, x8: G;
   concat4(k, h1, c, h2) <> concat8(x1, x2, x3, x4, x5, x6, x7, x8).

(* key table *)

table trusted_hosts(spkey).




(*
param N.

channel c_in, c_out.

type nondet [fixed].
type bounded_1000_payload [bounded].
type fixed_64 [fixed, large].
(********************************
  IND-CPA INT-CTXT encryption
*********************************)
type key.
type passwd [fixed, large].
type G [fixed].


type keyseed_T [fixed, large].
(* 100 is MAX_SIZE_KEY in the code. *)
type fixed_100_key [fixed].
type bounded_1000_ciphertext [bounded].
type bounded_200_cleartext [bounded].
type fixed_256_seed_T [fixed].

type spkey [bounded].
type sskey [bounded].
type skeyseed [large,fixed].
type sseed [fixed].
type signature [bounded].
type sblocksize [bounded].

proba Psign.
proba Psigncoll.
proba Penc.
proba Penccoll.
(*
expand IND_CCA2_public_key_enc(keyseed_T, spkey, sskey, bounded_200_cleartext, bounded_1000_ciphertext, fixed_256_seed_T, pk, ek, enc, dec, injbot, Z, Penc, Penccoll).*)


fun kgen(bitstring, fixed_64): bitstring.

equation forall a:fixed_64, b:fixed_64; kgen(kgen(g,a),b) = kgen(kgen(g,b),a).
proba Pmac.

expand UF_CMA_mac(skeyseed, spkey, bitstring, bitstring, mkgen, HMAC_sha1, HMAC_sha1_check, Pmac).

equation forall m: bitstring, k: spkey, r: bitstring;
  ((HMAC_sha1(m, k)) = r) = HMAC_sha1_check(m, k, r).

(* CR-someday: giving this a precise return type would allow to remove more checks. *) 
fun HMAC(bitstring, bitstring, spkey): bitstring.
  
const arithmetic1: bitstring.

(* ASSERT_DEFINITION
  arithmetic1/0
  "sha1"
*)

equation forall m: bitstring, k: spkey;
  HMAC(arithmetic1, m, k) = HMAC_sha1(m, k).

(*
expand UF_CMA_signature(skeyseed, spkey, sskey, sblocksize, signature, sseed, sk, vk, sign, check, Psign, Psigncoll).

fun cert(fixed_100_key, bounded_40_host): sblocksize [compos].

fun check_key(bounded_40_host, fixed_100_key, signature, spkey): bool.

forall h: bounded_40_host, k: fixed_100_key, sig: signature, pkS: spkey;
  check_key(h, k, sig, pkS) = check(cert(k, h), pkS, sig).*)

(*************************** 
  Key lookup
***************************)

fun kdfPtoS(bitstring, bitstring): fixed_100_key.
fun kdfStoP(bitstring, bitstring): fixed_100_key.
(* the ids of a designated pair of honest participants *) 


const user_answer: bounded_1000_ciphertext.
const user_auth: signature.
const inputs: bounded_1000_ciphertext.
const server_sign: bitstring.


fun pk(skeyseed):spkey.
fun sign(bounded_1000_ciphertext, skeyseed): signature.
fun verify(signature, spkey): bool.
equation forall x: bounded_1000_ciphertext, y: skeyseed; verify(sign(x,y), pk(y)) = true.

fun to_sig(bitstring):signature.
fun trans(bitstring):spkey.
fun to_cipher(bitstring):bounded_1000_ciphertext.
const g : bitstring.

fun enc(signature, fixed_100_key): bounded_1000_ciphertext.
fun dec(bounded_1000_ciphertext, fixed_100_key): signature.
equation forall h: signature, i: fixed_100_key;
  dec(enc(h,i),i) = h.


(*************************** 
  Formatting Functions 
***************************)



(*************************** 
  Parsing Equations 
***************************)


(*************************** 
  Arithmetic Functions 
***************************)


(*************************** 
  Auxiliary Tests 
***************************)


(*************************** 
  Zero Functions 
***************************)

fun Zbitstring(bitstring): bitstring.

fun Zbitstring_prime(bitstring): bitstring.

fun Zfixed_100_key(fixed_100_key): fixed_100_key.

fun Zfixed_100_key_prime(fixed_100_key): fixed_100_key.

fun Zfixed_64(fixed_64): fixed_64.

fun Zfixed_64_prime(fixed_64): fixed_64.

const zero_fixed_100_key: fixed_100_key.

const zero_fixed_64: fixed_64.


(*************************** 
  Primed Functions 
***************************)


(*************************** 
  Typecasting 
***************************)


(*************************** 
  Auxiliary Facts 
***************************)


(*************************** 
  Zero Facts 
***************************)

equation forall x: fixed_64;
	Zfixed_64(x) = zero_fixed_64().
equation forall x: fixed_100_key;
	Zfixed_100_key(x) = zero_fixed_100_key().
*)
fun kdfPtoS(G, macres): symkey.
fun kdfStoP(G, macres): symkey.
fun to_sig(bitstring):signature.
fun from_sig(signature):bitstring.
fun trans(bitstring):spkey.
fun from_bot_to_sig(bitstringbot):signature.
const bl: block.
const user_auth: bitstring.
fun to_bot(bitstring):bitstringbot.
fun from_bot(bitstringbot):bitstring.
const user_answer: block.
const inputs: block.
(********************************
  <Query>
*********************************)
(* Authentication of the client to the server *)

event AcceptS(spkey, spkey).
event AcceptP(spkey, spkey).
event AcceptS2(spkey, spkey).
event AcceptP2(spkey, spkey).

query i: spkey, j: spkey, l: spkey;
   event(AcceptP(i, j)) ==> event(AcceptS(i, l)).

query i: spkey, j: spkey;
   event(AcceptS2(i, j)) ==> event(AcceptP2(i, j)).

query i: spkey, j: spkey;
   event(AcceptP(i, j)) ==> true.

query i: spkey, j: spkey;
   event(AcceptS2(i, j)) ==> true.

query i: spkey, l: spkey;
   event(AcceptS(i, l)) ==> true.

query i: spkey, j: spkey;
   event(AcceptP2(i, j)) ==> true.

(*************************** 
  Model 
***************************)

let client(hk: mkey, pkS: spkey, pkP: spkey, skP: sskey) = 
in(c_in, ());
new a: Z;
let gA = exp(g,a) in
out(c_out, gA);
in(c_in, (B: G, sig: bitstring, opks: bitstring));
let sig1 = to_sig(sig) in
let opkst = trans(opks) in
if pkS = opkst then 
let h = mac(gA,B,hk) in
let k = exp(B,a) in
let x = check(bl,pkS,sig1) in
if x = true then 
event AcceptP(pkS, pkP);
let kPS = kdfPtoS(k,h) in
let kSP = kdfStoP(k,h) in
out(c_out, enc(user_auth,kPS));
in(c_in, userauth_answer: bitstring);
let user_auth1 = to_bot(user_auth) in
if dec(userauth_answer,kSP) = user_auth1 then 
event AcceptP2(pkS, pkP);
let sig2 = sign(user_answer,skP) in
let sig3 = from_sig(sig2) in
out(c_out, enc(sig3,kPS)); 0 .

let server(hk: mkey, pkP: spkey, pkS: spkey, skS: sskey) =
in(c_in, (a_63: bitstring, a_433: G));
new SKey_704: Z;
let sk_706 = exp(g,SKey_704) in
let kAB_708 = exp(a_433,SKey_704) in
let HMAC_714 = mac(a_433,sk_706,hk) in
event AcceptS(pkS, pkP);
let signature_720 = sign(inputs,skS) in
let kPS_724 = kdfPtoS(kAB_708,HMAC_714) in
let kSP_728 = kdfStoP(kAB_708,HMAC_714) in
out(c_out, (pkS, sign(inputs,skS), sk_706));
in(c_in, a_732: bitstring);
let Dec_733 = dec(a_732,kPS_724) in
let dec1 = from_bot(Dec_733) in
let Enc_736 = enc(dec1,kSP_728) in
out(c_out, Enc_736);
in(c_in, a_967: bitstring);
let Dec_968 = dec(a_967,kPS_724) in
let sig4 = from_bot_to_sig(Dec_968) in
let Ver_972 = check(bl,pkP,sig4) in
if Ver_972 = true then 
event AcceptS2(pkS, pkP);
yield .

(********************************
  <Environment>
*********************************)

process 
! N(
	in(c_in, ());
	new hk : mkey;
	new S_seed : skeyseed;
	let skS = sskgen(S_seed) in
	let pkS = spkgen(S_seed) in  
	out(c_out, pkS);
	! N (
		in(c_in, ());
		new P_seed : skeyseed;
		let skP = sskgen(P_seed) in
		let pkP = spkgen(P_seed) in	 
		out(c_out, pkP);
		(! N client(hk, pkS, pkP, skP)) | (! N server(hk, pkP, pkS, skS))
  )
)

